<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragon Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Arial', sans-serif;
            touch-action: manipulation;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            margin: 20px auto;
            overflow: hidden;
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
            border: 4px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
        }
        
        #gameCanvas {
            background-image: url('https://i.postimg.cc/bs0QLhQh/Colorful-Abstract-Dancing-Image-Dance-Studio-Logo.jpg');
            background-size: cover;
            display: block;
            border-radius: 16px;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        #menuScreen, #gameOverScreen, #levelCompleteScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85) 0%, rgba(0, 0, 0, 0.95) 100%);
            color: white;
            z-index: 10;
            border-radius: 16px;
            backdrop-filter: blur(5px);
        }
        
        h1 {
            font-size: 56px;
            margin-bottom: 40px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5),
                         0 0 20px rgba(255, 255, 255, 0.3),
                         0 0 30px rgba(255, 255, 255, 0.2);
            animation: glow 2s ease-in-out infinite alternate;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        h2 {
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            margin: 15px 0;
            font-size: 28px;
            font-weight: normal;
        }
        
        .button {
            width: 250px;
            height: 70px;
            margin: 20px;
            background: linear-gradient(135deg, #4a4a4a 0%, #333333 100%);
            color: white;
            border: none;
            border-radius: 35px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
        }
        
        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0) 100%);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        
        .button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        
        .button:hover::before {
            transform: translateX(100%);
        }
        
        .button:active {
            transform: translateY(2px) scale(0.98);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            z-index: 5;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.8) 100%);
            padding: 20px;
            border-radius: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 220px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
        }
        
        #abilityIndicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 250px;
            height: 25px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.7) 100%);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }
        
        #abilityBar {
            height: 100%;
            width: 100%;
            background: linear-gradient(135deg, #33ff33 0%, #28cc28 100%);
            transform-origin: left;
            transform: scaleX(0);
            transition: transform 0.1s;
            box-shadow: 0 0 15px rgba(51, 255, 51, 0.5);
        }
        
        #abilityText {
            position: absolute;
            bottom: 50px;
            left: 20px;
            color: white;
            font-size: 18px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.7) 100%);
            padding: 12px 20px;
            border-radius: 12px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .mobile-controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: none;
            z-index: 5;
        }
        
        .mobile-btn {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.8) 100%);
            border-radius: 50%;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 35px;
            user-select: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            touch-action: manipulation;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }
        
        .mobile-btn:active {
            transform: scale(0.9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        #dragonSelectScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85) 0%, rgba(0, 0, 0, 0.95) 100%);
            color: white;
            z-index: 10;
            padding: 30px;
            border-radius: 16px;
            backdrop-filter: blur(5px);
        }
        
        .dragon-options {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 30px;
            max-width: 600px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.7) 100%);
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }
        
        .dragon-option {
            width: 140px;
            padding: 15px;
            text-align: center;
            background: linear-gradient(135deg, rgba(51, 51, 255, 0.2) 0%, rgba(51, 51, 255, 0.1) 100%);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .dragon-option img {
            width: 100px;
            height: 100px;
            object-fit: contain;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
            transition: all 0.3s ease;
        }
        
        .dragon-option h3 {
            margin: 10px 0;
            font-size: 20px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            font-weight: bold;
        }
        
        .dragon-option p {
            margin: 5px 0;
            font-size: 14px;
            color: #ccc;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .dragon-option.selected {
            border: 2px solid #33ff33;
            background: linear-gradient(135deg, rgba(51, 255, 51, 0.2) 0%, rgba(51, 255, 51, 0.1) 100%);
            box-shadow: 0 0 30px rgba(51, 255, 51, 0.5);
            transform: scale(1.05);
        }
        
        #confirmDragonButton {
            position: relative;
            z-index: 20;
            margin-top: 40px;
            width: 250px;
            height: 60px;
            background: linear-gradient(135deg, #33ff33 0%, #28cc28 100%);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            letter-spacing: 1px;
        }
        
        #confirmDragonButton:hover {
            background: linear-gradient(135deg, #44ff44 0%, #33cc33 100%);
            transform: scale(1.05) translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        
        #confirmDragonButton:active {
            transform: scale(0.95) translateY(1px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        @keyframes glow {
            from {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #33ff33, 0 0 20px #33ff33;
            }
            to {
                text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #33ff33, 0 0 40px #33ff33;
            }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
            100% { transform: translateY(0px); }
        }
        
        .dragon-option {
            animation: float 3s ease-in-out infinite;
        }
        
        .button {
            animation: pulse 2s ease-in-out infinite;
        }
        
        .dragon-option {
            transition: all 0.2s ease;
            position: relative;
        }
        
        .dragon-option:active {
            transform: scale(0.95);
        }
        
        .dragon-option.selected {
            animation: selectedPulse 1s infinite;
        }
        
        @keyframes selectedPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #audioControls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            display: flex;
            gap: 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.8) 100%);
            padding: 10px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
        }
        
        #audioControls button {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        #audioControls button:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        #audioControls button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="audioControls">
            <button id="muteButton">üîä</button>
        </div>
        
        <div id="hud">
            <div>Score: <span id="scoreDisplay">0</span></div>
            <div>Level: <span id="levelDisplay">1</span></div>
            <div>Lives: <span id="livesDisplay">3</span></div>
            <div>Dragon: <span id="dragonDisplay">Dudu</span></div>
        </div>
        
        <div id="abilityIndicator">
            <div id="abilityBar"></div>
        </div>
        <div id="abilityText">Ability Ready (Press Space)</div>
        
        <div id="controlsInfo">
            Controls: Arrow Keys to Move | Space to Fire
        </div>
        
        <div id="menuScreen">
            <h1>Dragon Adventure</h1>
            <button class="button" id="startButton">Start Game</button>
            <button class="button" id="dragonSelectButton">Select Dragon</button>
            <button class="button" id="quitButton">Quit</button>
        </div>
        
        <div id="gameOverScreen">
            <h1>Game Over</h1>
            <h2>Final Score: <span id="finalScore">0</span></h2>
            <h2>Level Reached: <span id="finalLevel">1</span></h2>
            <button class="button" id="restartButton">Restart</button>
            <button class="button" id="quitButton2">Quit</button>
        </div>
        
        <div id="levelCompleteScreen">
            <h1>Level Complete!</h1>
            <h2>Score: <span id="levelScore">0</span></h2>
            <h2>Next Level: <span id="nextLevel">2</span></h2>
            <button class="button" id="nextLevelButton">Next Level</button>
            <button class="button" id="quitButton3">Quit</button>
        </div>
        
        <div class="mobile-controls" id="mobileControls">
            <div class="mobile-btn" id="upBtn">‚Üë</div>
            <div class="mobile-btn" id="downBtn">‚Üì</div>
            <div class="mobile-btn" id="leftBtn">‚Üê</div>
            <div class="mobile-btn" id="rightBtn">‚Üí</div>
            <div class="mobile-btn" id="abilityBtn">A</div>
        </div>
        
        <div id="dragonSelectScreen">
            <h1>Choose Your Dragon</h1>
            <div class="dragon-options" id="dragonOptions"></div>
            <button class="button" id="confirmDragonButton">Confirm Selection</button>
        </div>
    </div>

    <!-- Audio elements -->
    <audio id="bgMusic" loop preload="auto">
        <source src="assets/sounds/Background music (1).mp3" type="audio/mp3">
    </audio>
    <audio id="coinSound" preload="auto">
        <source src="assets/sounds/Collecting Coin.wav" type="audio/wav">
    </audio>
    <audio id="powerupSound" preload="auto">
        <source src="assets/sounds/Collecting bonus.wav" type="audio/wav">
    </audio>
    <audio id="gameOverSound" preload="auto">
        <source src="assets/sounds/Player loosing.wav" type="audio/wav">
    </audio>

    <!-- Additional game sounds using existing effects -->
    <audio id="bossSound" preload="auto">
        <source src="assets/sounds/Player loosing.wav" type="audio/wav">
    </audio>
    <audio id="fireballSound" preload="auto">
        <source src="assets/sounds/Collecting bonus.wav" type="audio/wav">
    </audio>
    <audio id="freezeSound" preload="auto">
        <source src="assets/sounds/Collecting bonus.wav" type="audio/wav">
    </audio>
    <audio id="lightningSound" preload="auto">
        <source src="assets/sounds/Collecting bonus.wav" type="audio/wav">
    </audio>
    <audio id="hitSound" preload="auto">
        <source src="assets/sounds/Player loosing.wav" type="audio/wav">
    </audio>
    <audio id="levelUpSound" preload="auto">
        <source src="assets/sounds/Collecting bonus.wav" type="audio/wav">
    </audio>

    <script>
        // Game Constants
        const DRAGON_TYPES = {
            "Nuko": { 
                color: "#ff9933", 
                speed: 4, 
                ability: "Fireball", 
                cooldown: 250, 
                damage: 2, 
                image: 'https://i.postimg.cc/dDNWxXs2/power-dragon.png', 
                width: 70, 
                height: 70,
                specialPower: "Power Surge", // Temporary power boost
                powerDuration: 4000,
                powerCooldown: 10000,
                availableUntilLevel: 999 // Always available
            },
            "Dudu": { 
                color: "#33ff33", 
                speed: 5, 
                ability: "Fireball", 
                cooldown: 200, 
                damage: 3, 
                image: 'https://i.postimg.cc/8jdVtg0X/Green-Cartoon-Dragon-Illustrated-T-Shirt-removebg-preview.png', 
                width: 60, 
                height: 60,
                specialPower: "Flame Shield",
                powerDuration: 5000,
                powerCooldown: 15000,
                availableUntilLevel: 999 // Always available
            },
            "Pichu": { 
                color: "#3333ff", 
                speed: 6, 
                ability: "Ice Blast", 
                cooldown: 300, 
                damage: 2, 
                image: 'https://i.postimg.cc/rDQ22CcS/Green-Cartoon-Dragon-Illustrated-T-Shirt-1-removebg-preview.png', 
                width: 60, 
                height: 60,
                specialPower: "Freeze Time", // Slows down all enemies
                powerDuration: 3000,
                powerCooldown: 10000,
                availableUntilLevel: 999 // Always available
            },
            "Muko": { 
                color: "#aa33ff", 
                speed: 7, 
                ability: "Lightning", 
                cooldown: 300, 
                damage: 2, 
                image: 'https://i.postimg.cc/mPbWn6xL/Green-Cartoon-Dragon-Illustrated-T-Shirt-2-removebg-preview.png', 
                width: 60, 
                height: 60,
                specialPower: "Chain Lightning", // Lightning jumps between enemies
                powerDuration: 4000,
                powerCooldown: 12000,
                availableUntilLevel: 999 // Always available
            },
            "Suku": { 
                color: "#ff3333", 
                speed: 8, 
                ability: "Thunder Storm", 
                cooldown: 500, 
                damage: 4, 
                image: 'https://i.postimg.cc/rK2k1wQt/Green-Cartoon-Dragon-Illustrated-T-Shirt-3-removebg-preview.png', 
                width: 80, 
                height: 80,
                specialPower: "Thunder God", // Creates a massive storm of lightning bolts
                powerDuration: 6000,
                powerCooldown: 20000,
                availableUntilLevel: 999 // Always available
            }
        };

        const BACKGROUNDS = [
            'https://i.postimg.cc/5XTdt9Y0/hills.png',               // Dragon hills
            'https://i.postimg.cc/0bt1L097/volcano.png',             // Dragon volcano
            'https://i.postimg.cc/5HShSBKH/background.png',          // Simple background
            'https://i.postimg.cc/p9vNjGCb/forest.jpg',              // Forest background
            'https://i.postimg.cc/1fL1m5Nz/green-grace-and-blue-sky.png', // Blue sky
            'https://i.postimg.cc/tsWQYQhN/playground.jpg'           // Playground background
        ];

        // Game Variables
        let canvas, ctx;
        let gameActive = false;
        let gameOver = false;
        let score = 0;
        let level = 1;
        let lives = 3;
        let currentDragon = "Dudu";
        let currentBackground = 0;
        let bossActive = false;
        let abilityCooldown = 0;
        let isAutoFiring = false;  // New variable for auto-fire
        let lastAutoFireTime = 0;  // Track last auto-fire time
        let powerupsActive = {
            speed_boost: false,
            invincible: false,
            magnet: false
        };
        let powerupEndTime = 0;
        let isMobile = false;
        let muted = false;

        // Add new game variables
        let specialPowerActive = false;
        let specialPowerEndTime = 0;
        let specialPowerCooldown = 0;
        let activeEffects = [];
        let powerupCooldown = 0;
        let lastPowerupTime = 0;
        let powerupDuration = 10000; // 10 seconds base duration
        let powerupLevelMultiplier = 1;

        // Initialize game objects
        let dragon = {
            x: 400,
            y: 500,
            width: 80,
            height: 80,
            dx: 0,
            dy: 0,
            speed: 5
        };
        
        let gems = [];
        let enemies = [];
        let powerups = [];
        let abilities = [];
        let boss = null;

        // Audio elements
        const audioElements = {
            bgMusic: document.getElementById('bgMusic'),
            coinSound: document.getElementById('coinSound'),
            powerupSound: document.getElementById('powerupSound'),
            gameOverSound: document.getElementById('gameOverSound'),
            bossSound: document.getElementById('bossSound'),
            fireballSound: document.getElementById('fireballSound'),
            freezeSound: document.getElementById('freezeSound'),
            lightningSound: document.getElementById('lightningSound'),
            hitSound: document.getElementById('hitSound'),
            levelUpSound: document.getElementById('levelUpSound')
        };

        // Initialize audio settings
        Object.values(audioElements).forEach(audio => {
            if (audio) {
                audio.volume = audio === audioElements.bgMusic ? 0.3 : 0.5;
                audio.addEventListener('error', (e) => {
                    console.error('Error loading audio:', e);
                });
            }
        });

        // Load images
        let bgImages = BACKGROUNDS.map(src => {
            const img = new Image();
            img.src = src;
            return img;
        });

        let dragonImages = {};
        Object.entries(DRAGON_TYPES).forEach(([name, data]) => {
            const img = new Image();
            img.src = data.image;
            dragonImages[name] = img;
        });

        let coinImage = new Image();
        coinImage.src = 'https://i.postimg.cc/0MbNMpCQ/gold-coin-removebg-preview.png';

        // Monster images
        let monsterImages = {
            basic: new Image(),
            bat: new Image(),
            ghost: new Image(),
            wolf: new Image()
        };
        monsterImages.basic.src = 'https://i.postimg.cc/0MFypbtC/monster-removebg-preview.png';
        monsterImages.bat.src = 'https://i.postimg.cc/nCxtP4jn/Bat-monster.png';
        monsterImages.ghost.src = 'https://i.postimg.cc/w1TY69QP/Blue-which.png';
        monsterImages.wolf.src = 'https://i.postimg.cc/SJGpFnCC/Wolf-monster.png';

        let powerupImage = new Image();
        powerupImage.src = 'https://i.postimg.cc/k2R3bf0L/star-removebg-preview.png';

        let magnetImage = new Image();
        magnetImage.src = 'https://i.postimg.cc/59P2G5X6/mb-removebg-preview-removebg-preview.png';

        let imagesLoaded = 0;
        const totalImages = BACKGROUNDS.length + Object.keys(DRAGON_TYPES).length + 7; // backgrounds + dragons + coin + monsters + powerup + magnet

        function imageLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                init();
            }
        }

        // Set up image load handlers
        bgImages.forEach(img => img.onload = imageLoaded);
        Object.values(dragonImages).forEach(img => img.onload = imageLoaded);
        coinImage.onload = imageLoaded;
        Object.values(monsterImages).forEach(img => img.onload = imageLoaded);
        powerupImage.onload = imageLoaded;
        magnetImage.onload = imageLoaded;

        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Check if mobile
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
                document.getElementById('mobileControls').style.display = 'block';
                setupMobileControls();
            } else {
                document.getElementById('controlsInfo').style.display = 'block';
            }
            
            // Event listeners
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', startGame);
            document.getElementById('nextLevelButton').addEventListener('click', nextLevel);
            document.getElementById('quitButton').addEventListener('click', () => window.close());
            document.getElementById('quitButton2').addEventListener('click', () => window.close());
            document.getElementById('quitButton3').addEventListener('click', () => window.close());
            document.getElementById('dragonSelectButton').addEventListener('click', showDragonSelection);
            document.getElementById('muteButton').addEventListener('click', toggleMute);
            
            // Keyboard controls
            window.addEventListener('keydown', keyDown);
            window.addEventListener('keyup', keyUp);
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        function toggleMute() {
            muted = !muted;
            Object.values(audioElements).forEach(audio => {
                if (audio) {
                    audio.muted = muted;
                }
            });
            document.getElementById('muteButton').textContent = muted ? "üîä" : "üîä";
        }

        function setupMobileControls() {
            const upBtn = document.getElementById('upBtn');
            const downBtn = document.getElementById('downBtn');
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const abilityBtn = document.getElementById('abilityBtn');
            
            // Touch events with improved responsiveness
            upBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                dragon.dy = -dragon.speed;
            });
            upBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (dragon.dy < 0) dragon.dy = 0;
            });
            
            downBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                dragon.dy = dragon.speed;
            });
            downBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (dragon.dy > 0) dragon.dy = 0;
            });
            
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                dragon.dx = -dragon.speed;
            });
            leftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (dragon.dx < 0) dragon.dx = 0;
            });
            
            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                dragon.dx = dragon.speed;
            });
            rightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (dragon.dx > 0) dragon.dx = 0;
            });
            
            abilityBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                useAbility();
            });
            
            // Add touch move event to canvas for direct dragon control
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // Calculate direction based on touch position relative to dragon
                const dx = x - (dragon.x + dragon.width/2);
                const dy = y - (dragon.y + dragon.height/2);
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance > 0) {
                    dragon.dx = (dx / distance) * dragon.speed;
                    dragon.dy = (dy / distance) * dragon.speed;
                }
            });
            
            canvas.addEventListener('touchend', () => {
                dragon.dx = 0;
                dragon.dy = 0;
            });
        }

        function keyDown(e) {
            if (!gameActive) return;
            
            const speed = dragon.speed * (powerupsActive.speed_boost ? 1.5 : 1);
            
            switch(e.key) {
                case 'ArrowLeft':
                    dragon.dx = -speed;
                    break;
                case 'ArrowRight':
                    dragon.dx = speed;
                    break;
                case 'ArrowUp':
                    dragon.dy = -speed;
                    break;
                case 'ArrowDown':
                    dragon.dy = speed;
                    break;
                case ' ':
                    isAutoFiring = true;
                    useAbility();
                    break;
                case 'm':
                    toggleMute();
                    break;
                case 'q': // Special power key
                    useSpecialPower();
                    break;
            }
        }

        function keyUp(e) {
            switch(e.key) {
                case 'ArrowLeft':
                    if (dragon.dx < 0) dragon.dx = 0;
                    break;
                case 'ArrowRight':
                    if (dragon.dx > 0) dragon.dx = 0;
                    break;
                case 'ArrowUp':
                    if (dragon.dy < 0) dragon.dy = 0;
                    break;
                case 'ArrowDown':
                    if (dragon.dy > 0) dragon.dy = 0;
                    break;
                case ' ':
                    isAutoFiring = false;  // Disable auto-fire on space release
                    break;
            }
        }

        function startGame() {
            // Reset game state
            gameActive = true;
            gameOver = false;
            score = 0;
            level = 1;
            lives = 3;
            bossActive = false;
            
            // Reset dragon
            dragon.x = 400;
            dragon.y = 500;
            dragon.dx = 0;
            dragon.dy = 0;
            dragon.speed = DRAGON_TYPES[currentDragon].speed;
            dragon.width = DRAGON_TYPES[currentDragon].width;
            dragon.height = DRAGON_TYPES[currentDragon].height;
            
            // Reset background to first one
            currentBackground = 0;
            
            // Clear all objects
            gems = [];
            enemies = [];
            powerups = [];
            abilities = [];
            boss = null;
            
            // Generate initial objects
            generateObjects();
            
            // Hide menus
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('levelCompleteScreen').style.display = 'none';
            
            // Update HUD
            updateHUD();
            
            // Start music
            playSound(audioElements.bgMusic);
        }

        function showDragonSelection() {
            gameActive = false;
            const dragonSelectScreen = document.getElementById('dragonSelectScreen');
            const dragonOptions = document.getElementById('dragonOptions');
            
            // Clear previous options
            dragonOptions.innerHTML = '';
            
            // Create dragon options
            Object.entries(DRAGON_TYPES).forEach(([name, data]) => {
                // Skip dragons that are not available for current level
                if (data.availableUntilLevel && level > data.availableUntilLevel) {
                    return;
                }
                
                const option = document.createElement('div');
                option.className = 'dragon-option' + (name === currentDragon ? ' selected' : '');
                option.innerHTML = `
                    <img src="${data.image}" alt="${name}">
                    <h3>${name}</h3>
                    <p>Speed: ${data.speed}</p>
                    <p>Ability: ${data.ability}</p>
                    <p>Damage: ${data.damage}</p>
                    ${data.availableUntilLevel ? `<p class="availability">Level ${data.availableUntilLevel}</p>` : ''}
                    <div class="tap-hint">Double tap/click to confirm</div>
                `;

                // Variables for double-click/tap detection
                let lastClickTime = 0;
                const doubleClickDelay = 300; // milliseconds

                // Handle both click and touch events
                const handleSelection = (e) => {
                    e.preventDefault();
                    const currentTime = Date.now();
                    
                    if (currentTime - lastClickTime < doubleClickDelay) {
                        // Double click/tap detected
                        document.querySelectorAll('.dragon-option').forEach(opt => {
                            opt.classList.remove('selected', 'confirmed');
                        });
                        option.classList.add('selected', 'confirmed');
                        currentDragon = name;
                        document.getElementById('dragonDisplay').textContent = name;
                        dragon.speed = DRAGON_TYPES[name].speed;
                        dragon.width = DRAGON_TYPES[name].width;
                        dragon.height = DRAGON_TYPES[name].height;
                        
                        // Play selection sound
                        playSound(audioElements.powerupSound);
                        
                        // Start next level after animation
                        setTimeout(() => {
                            playSound(audioElements.levelUpSound);
                            dragonSelectScreen.style.display = 'none';
                            startNextLevel();
                        }, 500);
                    } else {
                        // Single click/tap
                        document.querySelectorAll('.dragon-option').forEach(opt => {
                            opt.classList.remove('selected', 'confirmed');
                        });
                        option.classList.add('selected');
                        currentDragon = name;
                        document.getElementById('dragonDisplay').textContent = name;
                        dragon.speed = DRAGON_TYPES[name].speed;
                        dragon.width = DRAGON_TYPES[name].width;
                        dragon.height = DRAGON_TYPES[name].height;
                        
                        // Play selection sound
                        playSound(audioElements.powerupSound);
                    }
                    
                    lastClickTime = currentTime;
                };

                // Add both click and touch event listeners
                option.addEventListener('click', handleSelection);
                option.addEventListener('touchend', handleSelection);
                
                dragonOptions.appendChild(option);
            });
            
            // Show the dragon selection screen
            dragonSelectScreen.style.display = 'flex';
        }

        function nextLevel() {
            level++;
            
            // Show dragon selection screen every 5 levels
            if (level % 5 === 0) {
                showDragonSelection();
            } else {
                startNextLevel();
            }
        }

        function startNextLevel() {
            gameActive = true;
            bossActive = false;
            
            // Clear all objects including abilities and effects
            gems = [];
            enemies = [];
            abilities = [];
            activeEffects = [];
            boss = null;
            
            // Change background every 5 levels
            if (level % 5 === 0) {
                currentBackground = Math.floor((level / 5) - 1) % BACKGROUNDS.length;
            }
            
            // Generate new objects
            generateObjects();
            
            // Hide screens
            document.getElementById('levelCompleteScreen').style.display = 'none';
            document.getElementById('dragonSelectScreen').style.display = 'none';
            
            // Update HUD
            updateHUD();
            
            // Resume music if it was playing
            playSound(audioElements.bgMusic);
        }

        function showLevelComplete() {
            gameActive = false;
            document.getElementById('levelScore').textContent = score;
            document.getElementById('nextLevel').textContent = level + 1;
            document.getElementById('levelCompleteScreen').style.display = 'flex';
            playSound(audioElements.levelUpSound);
            audioElements.bgMusic.pause();
        }

        function generateObjects() {
            // Generate gems with increasing count but cap at a reasonable maximum
            const baseGemCount = 5;
            const maxGemCount = 30;
            const gemCount = Math.min(baseGemCount + level * 2, maxGemCount);
            
            for (let i = 0; i < gemCount; i++) {
                gems.push({
                    x: Math.random() * (canvas.width - 30),
                    y: Math.random() * -100 - 30,
                    width: 30,
                    height: 30,
                    speed: 1 + Math.random() * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    type: "coin"
                });
            }
            
            // Enhanced powerups based on level
            if (level % 2 === 0) {
                // Extra life every 2 levels
                powerups.push({
                    x: Math.random() * (canvas.width - 30),
                    y: Math.random() * -100 - 30,
                    width: 30,
                    height: 30,
                    speed: 1 + Math.random() * 1.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    type: "extra_life",
                    glow: true,
                    glowColor: "#ff0000"
                });
                
                // Speed boost every 2 levels
                powerups.push({
                    x: Math.random() * (canvas.width - 30),
                    y: Math.random() * -100 - 30,
                    width: 30,
                    height: 30,
                    speed: 1 + Math.random() * 1.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    type: "speed_boost",
                    glow: true,
                    glowColor: "#33ff33"
                });

                // New powerup: Rapid Fire
                if (level >= 5) {
                    powerups.push({
                        x: Math.random() * (canvas.width - 30),
                        y: Math.random() * -100 - 30,
                        width: 30,
                        height: 30,
                        speed: 1 + Math.random() * 1.5,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.1,
                        type: "rapid_fire",
                        glow: true,
                        glowColor: "#ff9933",
                        duration: 10000,
                        cooldownReduction: 0.5
                    });
                }
            }
            
            // Magnet every 6 levels
            if (level % 6 === 0) {
                powerups.push({
                    x: Math.random() * (canvas.width - 30),
                    y: Math.random() * -100 - 30,
                    width: 30,
                    height: 30,
                    speed: 1 + Math.random() * 1.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    type: "magnet",
                    glow: true,
                    glowColor: "#3333ff"
                });
            }
            
            // Generate enemies with increasing difficulty based on level
            if (level > 1) {
                const baseEnemyCount = Math.floor(level / 3);
                const maxEnemyCount = 8;
                const enemyCount = Math.min(baseEnemyCount, maxEnemyCount);
                
                for (let i = 0; i < enemyCount; i++) {
                    const speedMultiplier = 1 + Math.min(level * 0.05, 1);
                    const sizeMultiplier = 1 + Math.min(Math.floor(level / 10) * 0.2, 0.6);
                    
                    // Determine monster type based on level
                    let monsterType = "basic";
                    if (level >= 10) monsterType = "bat";
                    if (level >= 20) monsterType = "ghost";
                    if (level >= 30) monsterType = "wolf";
                    
                    const baseSize = monsterType === "bat" ? 50 : 40;
                    const baseSpeed = monsterType === "ghost" ? 0.7 : 0.5;
                    
                    enemies.push({
                        x: Math.random() * (canvas.width - 40),
                        y: Math.random() * -100 - 40,
                        width: baseSize * sizeMultiplier,
                        height: baseSize * sizeMultiplier,
                        speed: (baseSpeed + Math.random() * 0.5) * speedMultiplier,
                        frozen: false,
                        frozenTime: 0,
                        originalSpeed: (baseSpeed + Math.random() * 0.5) * speedMultiplier,
                        type: monsterType,
                        health: Math.floor(1 + level / 5),
                        maxHealth: Math.floor(1 + level / 5)
                    });
                }
            }
            
            // Generate boss every 10 levels
            if (level % 10 === 0) {
                spawnBoss();
            }
        }

        function spawnBoss() {
            bossActive = true;
            const bossLevel = Math.floor(level / 10);
            const healthMultiplier = 1 + (bossLevel - 1) * 0.4;
            const speedMultiplier = 1 + Math.min((bossLevel - 1) * 0.15, 0.6);
            const sizeMultiplier = 1 + Math.min((bossLevel - 1) * 0.2, 0.8);
            
            // Determine boss type based on level
            let bossType = "basic";
            if (level >= 20) bossType = "ghost";
            if (level >= 30) bossType = "wolf";
            
            const baseSize = bossType === "ghost" ? 120 : 100;
            
            boss = {
                x: canvas.width / 2 - 50,
                y: 100,
                width: baseSize * sizeMultiplier,
                height: baseSize * sizeMultiplier,
                speed: 2.5 * speedMultiplier,
                direction: 1,
                health: 150 * healthMultiplier,
                maxHealth: 150 * healthMultiplier,
                attackCooldown: 0,
                attackPattern: 0,
                attackTimer: 0,
                level: bossLevel,
                type: bossType,
                shieldActive: false,
                shieldCooldown: 0,
                shieldDuration: 3000,
                specialAttackCooldown: 0,
                specialAttackPattern: 0,
                invulnerable: false,
                invulnerableTime: 0
            };
            playSound(audioElements.bossSound);
        }

        function useAbility() {
            if (Date.now() < abilityCooldown) return;
            
            abilityCooldown = Date.now() + DRAGON_TYPES[currentDragon].cooldown;
            lastAutoFireTime = Date.now();
            updateAbilityBar();
            
            switch(currentDragon) {
                case "Nuko":
                    playSound(audioElements.fireballSound);
                    // Enhanced fireball for Nuko with multiple projectiles
                    for (let i = 0; i < 3; i++) {
                        abilities.push({
                            x: dragon.x + dragon.width/2 - 15 + (i - 1) * 20,
                            y: dragon.y - 20,
                            width: 30,
                            height: 30,
                            speed: 25,
                            damage: DRAGON_TYPES[currentDragon].damage * 1.5,
                            type: "fireball",
                            isNuko: true,
                            spread: (i - 1) * 0.2,
                            trail: true // Add trailing effect
                        });
                    }
                    break;
                    
                case "Dudu":
                    playSound(audioElements.fireballSound);
                    abilities.push({
                        x: dragon.x + dragon.width/2 - 10,
                        y: dragon.y - 20,
                        width: 20,
                        height: 20,
                        speed: 20,
                        damage: DRAGON_TYPES[currentDragon].damage,
                        type: "fireball",
                        isDudu: true,
                        flame: true // Add flame effect
                    });
                    break;
                    
                case "Pichu":
                    playSound(audioElements.freezeSound);
                    // Enhanced ice blast with improved effects
                    abilities.push({
                        x: dragon.x + dragon.width/2 - 15,
                        y: dragon.y - 20,
                        width: 30,
                        height: 30,
                        speed: 20, // Increased speed
                        damage: DRAGON_TYPES[currentDragon].damage * 1.5, // Increased damage
                        type: "ice_blast",
                        freezeDuration: 4000, // Longer freeze duration
                        freezeRadius: 70, // Larger area of effect
                        iceCrystals: true,
                        // Enhanced particle effects
                        spread: 0.8,
                        particles: 12,
                        particleSize: 6,
                        particleSpeed: 3,
                        particleLifetime: 40,
                        // New properties for better ice blast
                        waveEffect: true,
                        waveCount: 3,
                        waveSpeed: 2,
                        waveSize: 20
                    });
                    break;
                    
                case "Muko":
                    playSound(audioElements.lightningSound);
                    // Enhanced chain lightning with more bolts
                    for (let i = 0; i < 5; i++) {
                        abilities.push({
                            x: dragon.x + dragon.width/2 - 5 + (i - 2) * 20,
                            y: dragon.y - dragon.height/2,
                            width: 10,
                            height: 30,
                            lifetime: 20,
                            damage: DRAGON_TYPES[currentDragon].damage,
                            type: "lightning",
                            chain: true,
                            maxJumps: 3,
                            glow: true // Add glow effect
                        });
                    }
                    break;
                    
                case "Suku":
                    playSound(audioElements.fireballSound);
                    // Enhanced thunder with multiple strikes and area effect
                    for (let i = 0; i < 3; i++) {
                        abilities.push({
                            x: dragon.x + dragon.width/2 - 15 + (i - 1) * 30,
                            y: dragon.y - dragon.height/2,
                            width: 30,
                            height: 40,
                            speed: 18,
                            damage: DRAGON_TYPES[currentDragon].damage * 1.5,
                            type: "thunder",
                            area: true,
                            shockwave: true,
                            radius: 60,
                            // New properties for enhanced thunder
                            chain: true,
                            maxChains: 2,
                            stunDuration: 2000,
                            particles: 8,
                            particleSize: 4,
                            particleSpeed: 2
                        });
                    }
                    break;
            }
        }

        function useSpecialPower() {
            if (Date.now() < specialPowerCooldown) return;
            
            specialPowerActive = true;
            specialPowerEndTime = Date.now() + DRAGON_TYPES[currentDragon].powerDuration;
            specialPowerCooldown = Date.now() + DRAGON_TYPES[currentDragon].powerCooldown;
            
            switch(currentDragon) {
                case "Nuko":
                    // Enhanced Power Surge effect
                    activeEffects.push({
                        type: "powerSurge",
                        startTime: Date.now(),
                        duration: DRAGON_TYPES[currentDragon].powerDuration
                    });
                    // Temporarily increase damage and speed
                    dragon.speed *= 2.5;
                    dragon.damage = DRAGON_TYPES[currentDragon].damage * 4;
                    // Add visual effect
                    activeEffects.push({
                        type: "powerSpark",
                        x: dragon.x + dragon.width/2,
                        y: dragon.y + dragon.height/2,
                        size: 40,
                        color: "#ff9933"
                    });
                    // Add multiple sparks with enhanced effects
                    for (let i = 0; i < 8; i++) {
                        activeEffects.push({
                            type: "powerSpark",
                            x: dragon.x + Math.random() * dragon.width,
                            y: dragon.y + Math.random() * dragon.height,
                            size: 15 + Math.random() * 15,
                            color: "#ff9933",
                            trail: true
                        });
                    }
                    break;
                    
                case "Dudu":
                    // Enhanced flame shield effect
                    activeEffects.push({
                        type: "flameShield",
                        startTime: Date.now(),
                        duration: DRAGON_TYPES[currentDragon].powerDuration
                    });
                    // Make dragon invincible during shield
                    powerupsActive.invincible = true;
                    powerupEndTime = Date.now() + DRAGON_TYPES[currentDragon].powerDuration;
                    // Add damage reflection with enhanced effect
                    activeEffects.push({
                        type: "flameReflect",
                        startTime: Date.now(),
                        duration: DRAGON_TYPES[currentDragon].powerDuration,
                        damageMultiplier: 2
                    });
                    break;
                    
                case "Pichu":
                    // Enhanced freeze effect
                    enemies.forEach(enemy => {
                        enemy.frozen = true;
                        enemy.frozenTime = Date.now() + DRAGON_TYPES[currentDragon].powerDuration;
                        // Add ice crystal effect to frozen enemies
                        activeEffects.push({
                            type: "iceCrystal",
                            x: enemy.x + enemy.width/2,
                            y: enemy.y + enemy.height/2,
                            size: 15,
                            rotation: Math.random() * Math.PI * 2,
                            glow: true,
                            attachedTo: enemy
                        });
                    });
                    // Add visual effect
                    activeEffects.push({
                        type: "freezeEffect",
                        startTime: Date.now(),
                        duration: DRAGON_TYPES[currentDragon].powerDuration
                    });
                    // Add more ice crystals with enhanced effects
                    for (let i = 0; i < 15; i++) {
                        activeEffects.push({
                            type: "iceCrystal",
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            size: 8 + Math.random() * 12,
                            rotation: Math.random() * Math.PI * 2,
                            glow: true
                        });
                    }
                    break;
                    
                case "Muko":
                    // Enhanced chain lightning effect
                    activeEffects.push({
                        type: "chainLightning",
                        startTime: Date.now(),
                        duration: DRAGON_TYPES[currentDragon].powerDuration,
                        targets: [],
                        maxChains: 5
                    });
                    // Initial lightning strike with more bolts
                    for (let i = 0; i < 7; i++) {
                        abilities.push({
                            x: dragon.x + dragon.width/2 - 5 + (i - 3) * 20,
                            y: dragon.y - dragon.height/2,
                            width: 10,
                            height: 30,
                            lifetime: 20,
                            damage: DRAGON_TYPES[currentDragon].damage * 2,
                            type: "lightning",
                            chain: true,
                            maxJumps: 3,
                            glow: true
                        });
                    }
                    break;
                    
                case "Suku":
                    // Enhanced thunder god effect
                    activeEffects.push({
                        type: "thunderGod",
                        startTime: Date.now(),
                        duration: DRAGON_TYPES[currentDragon].powerDuration,
                        bolts: [],
                        area: true,
                        stormRadius: 200,
                        boltCount: 12
                    });
                    
                    // Create initial storm of lightning bolts
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const distance = Math.random() * 200;
                        const x = dragon.x + dragon.width/2 + Math.cos(angle) * distance;
                        const y = dragon.y + dragon.height/2 + Math.sin(angle) * distance;
                        
                        abilities.push({
                            x: x,
                            y: y,
                            width: 30,
                            height: 40,
                            speed: 18,
                            damage: DRAGON_TYPES[currentDragon].damage * 2,
                            type: "thunder",
                            area: true,
                            shockwave: true,
                            radius: 80,
                            chain: true,
                            maxChains: 3,
                            stunDuration: 3000,
                            particles: 12,
                            particleSize: 6,
                            particleSpeed: 3
                        });
                    }
                    break;
            }
        }

        function updateAbilityBar() {
            const abilityBar = document.getElementById('abilityBar');
            abilityBar.style.transform = 'scaleX(0)';
            
            const startTime = Date.now();
            const endTime = abilityCooldown;
            const duration = DRAGON_TYPES[currentDragon].cooldown;
            
            function animate() {
                const now = Date.now();
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                abilityBar.style.transform = `scaleX(${progress})`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    document.getElementById('abilityText').textContent = "Ability Ready (Press Space)";
                }
            }
            
            document.getElementById('abilityText').textContent = DRAGON_TYPES[currentDragon].ability + " Cooldown";
            animate();
        }

        function gameLoop() {
            if (gameActive) {
                update();
            }
            render();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Auto-fire handling
            if (isAutoFiring && Date.now() - lastAutoFireTime >= DRAGON_TYPES[currentDragon].cooldown) {
                useAbility();
                lastAutoFireTime = Date.now();
            }

            // Update dragon position
            dragon.x += dragon.dx;
            dragon.y += dragon.dy;
            
            // Keep dragon in bounds
            dragon.x = Math.max(0, Math.min(canvas.width - dragon.width, dragon.x));
            dragon.y = Math.max(0, Math.min(canvas.height - dragon.height, dragon.y));
            
            // Update gems (falling and rotating)
            for (let i = gems.length - 1; i >= 0; i--) {
                const gem = gems[i];
                gem.y += gem.speed;
                gem.rotation += gem.rotationSpeed;
                
                // Wrap around if off screen
                if (gem.y > canvas.height) {
                    gem.y = Math.random() * -100 - 30;
                    gem.x = Math.random() * (canvas.width - 30);
                }
                
                // Check collision with dragon
                if (checkCollision(dragon, gem)) {
                    gems.splice(i, 1);
                    score += 10;
                    updateHUD();
                    playSound(audioElements.coinSound);
                }
            }
            
            // Magnet powerup effect
            if (powerupsActive.magnet) {
                gems.forEach(gem => {
                    const dx = dragon.x + dragon.width/2 - (gem.x + gem.width/2);
                    const dy = dragon.y + dragon.height/2 - (gem.y + gem.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance > 0) {
                        gem.x += dx / distance * 3;
                        gem.y += dy / distance * 3;
                    }
                });
            }
            
            // Check powerup expiration
            if (powerupsActive.speed_boost || powerupsActive.invincible || powerupsActive.magnet) {
                if (Date.now() > powerupEndTime) {
                    powerupsActive.speed_boost = false;
                    powerupsActive.invincible = false;
                    powerupsActive.magnet = false;
                }
            }
            
            // Check powerup collisions with enhanced effects
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                powerup.y += powerup.speed;
                powerup.rotation += powerup.rotationSpeed;
                
                // Wrap around if off screen
                if (powerup.y > canvas.height) {
                    powerups.splice(i, 1);
                    continue;
                }
                
                // Check collision with dragon
                if (checkCollision(dragon, powerup)) {
                    powerups.splice(i, 1);
                    
                    if (powerup.type === "extra_life") {
                        lives++;
                        playSound(audioElements.powerupSound);
                    } else {
                        // Enhanced powerup effects based on rarity
                        const durationMultiplier = powerup.isRare ? 1.5 : 1;
                        powerupsActive[powerup.type] = true;
                        powerupEndTime = Date.now() + (powerupDuration * durationMultiplier);
                        
                        // Special effects for rare powerups
                        if (powerup.isRare) {
                            switch(powerup.type) {
                                case "speed_boost":
                                    dragon.speed *= 1.5;
                                    break;
                                case "invincible":
                                    // Add visual shield effect
                                    activeEffects.push({
                                        type: "shield",
                                        startTime: Date.now(),
                                        duration: powerupDuration * 1.5
                                    });
                                    break;
                                case "magnet":
                                    // Enhanced magnet range
                                    gems.forEach(gem => {
                                        const dx = dragon.x + dragon.width/2 - (gem.x + gem.width/2);
                                        const dy = dragon.y + dragon.height/2 - (gem.y + gem.height/2);
                                        const distance = Math.sqrt(dx*dx + dy*dy);
                                        
                                        if (distance < 300) { // Increased range
                                            gem.x += dx / distance * 5;
                                            gem.y += dy / distance * 5;
                                        }
                                    });
                                    break;
                            }
                        }
                        
                        playSound(audioElements.powerupSound);
                    }
                    updateHUD();
                }
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Skip if frozen
                if (enemy.frozen && Date.now() < enemy.frozenTime) {
                    continue;
                } else if (enemy.frozen) {
                    enemy.frozen = false;
                }
                
                enemy.y += enemy.speed;
                
                // Wrap around if off screen
                if (enemy.y > canvas.height) {
                    enemy.y = Math.random() * -100 - 40;
                    enemy.x = Math.random() * (canvas.width - enemy.width);
                }
                
                // Check collision with dragon
                if (!powerupsActive.invincible && checkCollision(dragon, enemy)) {
                    lives--;
                    updateHUD();
                    playSound(audioElements.hitSound);
                    
                    if (lives <= 0) {
                        gameOver = true;
                        gameActive = false;
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalLevel').textContent = level;
                        document.getElementById('gameOverScreen').style.display = 'flex';
                        playSound(audioElements.gameOverSound);
                        audioElements.bgMusic.pause();
                    } else {
                        // Brief invincibility after hit
                        powerupsActive.invincible = true;
                        powerupEndTime = Date.now() + 2000;
                    }
                    
                    enemies.splice(i, 1);
                }
            }
            
            // Update abilities
            for (let i = abilities.length - 1; i >= 0; i--) {
                const ability = abilities[i];
                
                if (ability.type === "fireball") {
                    ability.y -= ability.speed;
                    
                    // Check if off screen
                    if (ability.y + ability.height < 0) {
                        abilities.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with enemies
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (checkCollision(ability, enemies[j])) {
                            enemies.splice(j, 1);
                            abilities.splice(i, 1);
                            score += 20;
                            updateHUD();
                            playSound(audioElements.hitSound);
                            break;
                        }
                    }
                    
                    // Check collision with boss
                    if (bossActive && checkCollision(ability, boss)) {
                        boss.health -= ability.damage;
                        abilities.splice(i, 1);
                        playSound(audioElements.hitSound);
                        
                        if (boss.health <= 0) {
                            bossActive = false;
                            score += 100 * level;
                            updateHUD();
                            playSound(audioElements.bossSound);
                        }
                    }
                }
                else if (ability.type === "lightning") {
                    ability.lifetime--;
                    
                    if (ability.lifetime <= 0) {
                        abilities.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with enemies
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (checkCollision(ability, enemies[j])) {
                            enemies.splice(j, 1);
                            score += 20;
                            updateHUD();
                            playSound(audioElements.hitSound);
                        }
                    }
                    
                    // Check collision with boss
                    if (bossActive && checkCollision(ability, boss)) {
                        boss.health -= ability.damage;
                        playSound(audioElements.hitSound);
                        
                        if (boss.health <= 0) {
                            bossActive = false;
                            score += 100 * level;
                            updateHUD();
                            playSound(audioElements.bossSound);
                        }
                    }
                }
                else if (ability.type === "ice_blast") {
                    ability.y -= ability.speed;
                    
                    // Check if off screen
                    if (ability.y + ability.height < 0) {
                        abilities.splice(i, 1);
                        continue;
                    }
                    
                    // Create enhanced ice particles
                    if (ability.particles > 0) {
                        for (let j = 0; j < ability.particles; j++) {
                            const angle = (j / ability.particles) * Math.PI * 2 + ability.spread;
                            const particle = {
                                x: ability.x + ability.width/2,
                                y: ability.y + ability.height/2,
                                size: ability.particleSize,
                                speed: ability.particleSpeed,
                                angle: angle,
                                lifetime: ability.particleLifetime,
                                // Add new particle properties
                                rotation: Math.random() * Math.PI * 2,
                                rotationSpeed: (Math.random() - 0.5) * 0.1,
                                glow: true
                            };
                            activeEffects.push({
                                type: "iceParticle",
                                ...particle
                            });
                        }
                    }
                    
                    // Add wave effect
                    if (ability.waveEffect) {
                        for (let w = 0; w < ability.waveCount; w++) {
                            activeEffects.push({
                                type: "iceWave",
                                x: ability.x + ability.width/2,
                                y: ability.y + ability.height/2,
                                size: ability.waveSize + w * 10,
                                speed: ability.waveSpeed,
                                lifetime: 30,
                                rotation: Math.random() * Math.PI * 2
                            });
                        }
                    }
                    
                    // Check collision with enemies
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const dx = (ability.x + ability.width/2) - (enemy.x + enemy.width/2);
                        const dy = (ability.y + ability.height/2) - (enemy.y + enemy.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance < ability.freezeRadius) {
                            enemy.frozen = true;
                            enemy.frozenTime = Date.now() + ability.freezeDuration;
                            enemy.originalSpeed = enemy.speed;
                            enemy.speed *= 0.05; // More effective slowdown
                            
                            // Enhanced ice crystal effect
                            activeEffects.push({
                                type: "iceCrystal",
                                x: enemy.x + enemy.width/2,
                                y: enemy.y + enemy.height/2,
                                size: 20,
                                rotation: Math.random() * Math.PI * 2,
                                glow: true,
                                attachedTo: enemy,
                                // New crystal properties
                                pulse: true,
                                pulseSpeed: 0.1,
                                pulseSize: 5
                            });
                            
                            if (distance < ability.width/2) {
                                enemies.splice(j, 1);
                                score += 25; // Increased score for direct hits
                                updateHUD();
                                playSound(audioElements.hitSound);
                            }
                        }
                    }
                    
                    abilities.splice(i, 1);
                }
            }
            
            // Update boss
            if (bossActive) {
                // Boss movement pattern with improved AI
                if (!boss.invulnerable) {
                    boss.x += boss.speed * boss.direction;
                    
                    // Change direction at edges with slight randomization
                    if (boss.x + boss.width > canvas.width || boss.x < 0) {
                        boss.direction *= -1;
                        boss.y += (Math.random() - 0.5) * 20; // Random vertical movement
                    }
                    
                    // Keep boss in bounds
                    boss.y = Math.max(50, Math.min(200, boss.y));
                }
                
                // Shield activation
                if (Date.now() > boss.shieldCooldown && !boss.shieldActive && boss.health < boss.maxHealth * 0.5) {
                    boss.shieldActive = true;
                    boss.shieldCooldown = Date.now() + 10000; // 10 second cooldown
                    boss.invulnerable = true;
                    boss.invulnerableTime = Date.now() + boss.shieldDuration;
                }
                
                // Shield deactivation
                if (boss.shieldActive && Date.now() > boss.invulnerableTime) {
                    boss.shieldActive = false;
                    boss.invulnerable = false;
                }
                
                // Boss attack patterns with enhanced difficulty
                if (Date.now() > boss.attackCooldown) {
                    const attackDelay = Math.max(1800 - (boss.level - 1) * 100, 1000);
                    boss.attackCooldown = Date.now() + attackDelay;
                    boss.attackPattern = (boss.attackPattern + 1) % 4;
                    
                    const projectileSpeed = 1.2 + Math.min(boss.level * 0.1, 1);
                    
                    switch(boss.attackPattern) {
                        case 0:  // Single strong projectile with tracking
                            const trackingEnemy = {
                                x: boss.x + boss.width/2 - 20,
                                y: boss.y + boss.height,
                                width: 40,
                                height: 40,
                                speed: projectileSpeed * 1.2,
                                frozen: false,
                                frozenTime: 0,
                                tracking: true,
                                targetX: dragon.x + dragon.width/2,
                                targetY: dragon.y + dragon.height/2
                            };
                            enemies.push(trackingEnemy);
                            break;
                        
                        case 1:  // Multiple smaller projectiles with spread
                            const projectileCount = Math.min(3 + Math.floor(boss.level / 2), 7);
                            for(let i = 0; i < projectileCount; i++) {
                                const spread = (i - (projectileCount - 1) / 2) * 0.2;
                                enemies.push({
                                    x: boss.x + (boss.width/projectileCount) * i,
                                    y: boss.y + boss.height,
                                    width: 30,
                                    height: 30,
                                    speed: projectileSpeed,
                                    frozen: false,
                                    frozenTime: 0,
                                    spread: spread
                                });
                            }
                            break;
                        
                        case 2:  // Spread shot with homing
                            const spreadCount = Math.min(3 + Math.floor(boss.level / 3), 5);
                            for(let i = -(spreadCount-1)/2; i <= (spreadCount-1)/2; i++) {
                                const enemy = {
                                    x: boss.x + boss.width/2 - 15,
                                    y: boss.y + boss.height,
                                    width: 30,
                                    height: 30,
                                    speed: projectileSpeed,
                                    frozen: false,
                                    frozenTime: 0,
                                    dx: i,
                                    homing: true,
                                    homingStrength: 0.05
                                };
                                enemies.push(enemy);
                            }
                            break;
                            
                        case 3:  // Special attack - Circular spread
                            if (Date.now() > boss.specialAttackCooldown) {
                                const specialCount = 8;
                                for(let i = 0; i < specialCount; i++) {
                                    const angle = (i / specialCount) * Math.PI * 2;
                                    enemies.push({
                                        x: boss.x + boss.width/2 - 15,
                                        y: boss.y + boss.height/2 - 15,
                                        width: 30,
                                        height: 30,
                                        speed: projectileSpeed * 1.5,
                                        frozen: false,
                                        frozenTime: 0,
                                        angle: angle,
                                        circular: true
                                    });
                                }
                                boss.specialAttackCooldown = Date.now() + 15000; // 15 second cooldown
                            }
                            break;
                    }
                }
                
                // Update enemy movement for enhanced patterns
                enemies.forEach(enemy => {
                    if (enemy.tracking) {
                        // Update tracking target
                        enemy.targetX = dragon.x + dragon.width/2;
                        enemy.targetY = dragon.y + dragon.height/2;
                        
                        // Move towards target
                        const dx = enemy.targetX - (enemy.x + enemy.width/2);
                        const dy = enemy.targetY - (enemy.y + enemy.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distance > 0) {
                            enemy.x += (dx / distance) * enemy.speed;
                            enemy.y += (dy / distance) * enemy.speed;
                        }
                    } else if (enemy.homing) {
                        // Homing movement
                        const dx = dragon.x + dragon.width/2 - (enemy.x + enemy.width/2);
                        const dy = dragon.y + dragon.height/2 - (enemy.y + enemy.height/2);
                        enemy.x += dx * enemy.homingStrength;
                        enemy.y += enemy.speed;
                    } else if (enemy.circular) {
                        // Circular movement
                        enemy.x += Math.cos(enemy.angle) * enemy.speed;
                        enemy.y += Math.sin(enemy.angle) * enemy.speed;
                    } else {
                        // Normal movement with spread
                        enemy.y += enemy.speed;
                        if (enemy.spread) {
                            enemy.x += enemy.spread * enemy.speed;
                        }
                    }
                });
            }
            
            // Level progression
            if (gems.length === 0 && !bossActive) {
                showLevelComplete();
            }
            
            // Update special power effects
            if (specialPowerActive) {
                if (Date.now() > specialPowerEndTime) {
                    specialPowerActive = false;
                    // Reset any active effects
                    if (currentDragon === "Pichu") {
                        enemies.forEach(enemy => {
                            enemy.speed = enemy.originalSpeed;
                        });
                    } else if (currentDragon === "Nuko") {
                        // Reset Nuko's speed and damage
                        dragon.speed = DRAGON_TYPES[currentDragon].speed;
                        dragon.damage = DRAGON_TYPES[currentDragon].damage;
                    }
                }
                
                // Update active effects
                activeEffects = activeEffects.filter(effect => {
                    if (Date.now() > effect.startTime + effect.duration) {
                        return false;
                    }
                    
                    switch(effect.type) {
                        case "powerSurge":
                            // Add visual effect for power surge
                            if (Math.random() < 0.1) {
                                activeEffects.push({
                                    type: "powerSpark",
                                    x: dragon.x + Math.random() * dragon.width,
                                    y: dragon.y + Math.random() * dragon.height,
                                    size: 5 + Math.random() * 5,
                                    color: "#ff9933"
                                });
                            }
                            break;
                            
                        case "flameShield":
                            // Check collisions with enemies
                            enemies.forEach((enemy, index) => {
                                if (checkCollision(dragon, enemy)) {
                                    enemies.splice(index, 1);
                                    score += 20;
                                }
                            });
                            break;
                            
                        case "chainLightning":
                            // Find new targets for chain lightning
                            if (enemies.length > 0 && effect.targets.length < 3) {
                                const newTarget = enemies[Math.floor(Math.random() * enemies.length)];
                                if (!effect.targets.includes(newTarget)) {
                                    effect.targets.push(newTarget);
                                    newTarget.health = (newTarget.health || 1) - 1;
                                    if (newTarget.health <= 0) {
                                        const index = enemies.indexOf(newTarget);
                                        if (index > -1) {
                                            enemies.splice(index, 1);
                                            score += 20;
                                        }
                                    }
                                }
                            }
                            break;
                            
                        case "thunderStorm":
                            // Generate new lightning bolts
                            if (Math.random() < 0.1) {
                                effect.bolts.push({
                                    x: Math.random() * canvas.width,
                                    y: 0,
                                    targetX: Math.random() * canvas.width,
                                    targetY: canvas.height
                                });
                                
                                // Check for enemy hits
                                enemies.forEach((enemy, index) => {
                                    if (Math.random() < 0.3) {
                                        enemy.health = (enemy.health || 1) - 1;
                                        if (enemy.health <= 0) {
                                            enemies.splice(index, 1);
                                            score += 20;
                                        }
                                    }
                                });
                            }
                            break;
                        case "iceParticle":
                            // Add ice particle effect
                            activeEffects.forEach(effect => {
                                effect.lifetime--;
                                if (effect.lifetime <= 0) {
                                    activeEffects.splice(activeEffects.indexOf(effect), 1);
                                }
                            });
                            break;
                        case "iceCrystal":
                            // Add ice crystal effect
                            activeEffects.forEach(effect => {
                                effect.lifetime--;
                                if (effect.lifetime <= 0) {
                                    activeEffects.splice(activeEffects.indexOf(effect), 1);
                                }
                            });
                            break;
                        case "iceWave":
                            // Add wave effect
                            activeEffects.forEach(effect => {
                                effect.lifetime--;
                                if (effect.lifetime <= 0) {
                                    activeEffects.splice(activeEffects.indexOf(effect), 1);
                                }
                            });
                            break;
                    }
                    return true;
                });
            }
        }

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('levelDisplay').textContent = level;
            document.getElementById('livesDisplay').textContent = lives;
        }

        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background with proper scaling and positioning
            const bgImage = bgImages[currentBackground];
            if (bgImage && bgImage.complete) {
                // Calculate scaling to cover the canvas while maintaining aspect ratio
                const scale = Math.max(
                    canvas.width / bgImage.width,
                    canvas.height / bgImage.height
                );
                
                const scaledWidth = bgImage.width * scale;
                const scaledHeight = bgImage.height * scale;
                
                // Center the background
                const x = (canvas.width - scaledWidth) / 2;
                const y = (canvas.height - scaledHeight) / 2;
                
                // Draw the background with a slight parallax effect based on dragon position
                const parallaxX = (dragon.x - canvas.width / 2) * 0.02;
                const parallaxY = (dragon.y - canvas.height / 2) * 0.02;
                
                ctx.save();
                ctx.drawImage(
                    bgImage,
                    x - parallaxX,
                    y - parallaxY,
                    scaledWidth,
                    scaledHeight
                );
                
                // Add a subtle gradient overlay for depth
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)');
                gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.restore();
            }
            
            if (gameActive) {
                // Draw gems with rotation
                gems.forEach(gem => {
                    ctx.save();
                    ctx.translate(gem.x + gem.width/2, gem.y + gem.height/2);
                    ctx.rotate(gem.rotation);
                    ctx.drawImage(coinImage, -gem.width/2, -gem.height/2, gem.width, gem.height);
                    ctx.restore();
                });
                
                // Draw powerups with glow effect
                powerups.forEach(powerup => {
                    ctx.save();
                    ctx.translate(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
                    ctx.rotate(powerup.rotation);
                    
                    // Enhanced glow effect for rare powerups
                    if (powerup.glow) {
                        const glowSize = powerup.glowIntensity + Math.sin(Date.now() / 200) * 3;
                        ctx.shadowColor = powerup.glowColor;
                        ctx.shadowBlur = glowSize;
                        
                        // Add pulsing effect for rare powerups
                        if (powerup.isRare) {
                            const scale = 1 + Math.sin(Date.now() / 300) * 0.1;
                            ctx.scale(scale, scale);
                        }
                    }
                    
                    // Draw powerup image
                    if (powerup.type === "magnet") {
                        ctx.drawImage(magnetImage, -powerup.width/2, -powerup.height/2, powerup.width, powerup.height);
                    } else {
                        ctx.drawImage(powerupImage, -powerup.width/2, -powerup.height/2, powerup.width, powerup.height);
                    }
                    
                    // Draw type indicator with enhanced style
                    if (powerup.type === "extra_life") {
                        ctx.fillStyle = "red";
                        ctx.font = "bold 20px Arial";
                        ctx.textAlign = "center";
                        ctx.fillText("+1", 0, 10);
                    }
                    
                    // Add rarity indicator
                    if (powerup.isRare) {
                        ctx.fillStyle = "#ffcc00";
                        ctx.font = "bold 16px Arial";
                        ctx.textAlign = "center";
                        ctx.fillText("RARE", 0, -15);
                    }
                    
                    ctx.restore();
                });
                
                // Draw enemies with their respective images
                enemies.forEach(enemy => {
                    const monsterImage = monsterImages[enemy.type];
                    if (enemy.frozen) {
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        ctx.drawImage(monsterImage, enemy.x, enemy.y, enemy.width, enemy.height);
                        ctx.restore();
                        
                        // Ice overlay
                        ctx.fillStyle = "rgba(100, 100, 255, 0.3)";
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    } else {
                        ctx.drawImage(monsterImage, enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                    
                    // Draw health bar for enemies with health > 1
                    if (enemy.health > 1) {
                        ctx.save();
                        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                        ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                        ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
                        ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / enemy.maxHealth), 5);
                        ctx.restore();
                    }
                });
                
                // Draw abilities with improved visuals
                abilities.forEach(ability => {
                    if (ability.type === "fireball") {
                        // Fireball gradient effect
                        const gradient = ctx.createRadialGradient(
                            ability.x + ability.width/2,
                            ability.y + ability.height/2,
                            0,
                            ability.x + ability.width/2,
                            ability.y + ability.height/2,
                            ability.width/2
                        );
                        gradient.addColorStop(0, '#ffffff');
                        gradient.addColorStop(0.3, '#ff9933');
                        gradient.addColorStop(1, '#ff3333');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(
                            ability.x + ability.width/2,
                            ability.y + ability.height/2,
                            ability.width/2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (ability.type === "lightning") {
                        // Lightning effect with glow
                        ctx.shadowColor = '#aa33ff';
                        ctx.shadowBlur = 10;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(ability.x + ability.width/2, ability.y);
                        ctx.lineTo(ability.x + ability.width/2, ability.y + ability.height);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else if (ability.type === "thunder") {
                        // Thunder effect
                        const gradient = ctx.createLinearGradient(
                            ability.x,
                            ability.y,
                            ability.x,
                            ability.y + ability.height
                        );
                        gradient.addColorStop(0, '#ffff33');
                        gradient.addColorStop(1, '#ff3333');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(ability.x, ability.y, ability.width, ability.height);
                    }
                });
                
                // Draw boss
                if (bossActive) {
                    const bossImage = monsterImages[boss.type];
                    if (boss.shieldActive) {
                        ctx.save();
                        ctx.globalAlpha = 0.7;
                        ctx.shadowColor = "#ff3333";
                        ctx.shadowBlur = 20;
                        ctx.drawImage(bossImage, boss.x, boss.y, boss.width, boss.height);
                        ctx.restore();
                        
                        // Draw shield effect
                        ctx.save();
                        ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(
                            boss.x + boss.width/2,
                            boss.y + boss.height/2,
                            boss.width/2 + 10,
                            0,
                            Math.PI * 2
                        );
                        ctx.stroke();
                        ctx.restore();
                    } else {
                        ctx.drawImage(bossImage, boss.x, boss.y, boss.width, boss.height);
                    }
                    
                    // Enhanced boss health bar
                    ctx.save();
                    // Health bar background with gradient
                    const gradient = ctx.createLinearGradient(boss.x + 10, boss.y - 20, boss.x + boss.width - 10, boss.y - 20);
                    gradient.addColorStop(0, "rgba(0, 0, 0, 0.7)");
                    gradient.addColorStop(1, "rgba(0, 0, 0, 0.5)");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(boss.x + 10, boss.y - 20, boss.width - 20, 10);
                    
                    // Health bar with gradient
                    const healthGradient = ctx.createLinearGradient(boss.x + 10, boss.y - 20, boss.x + boss.width - 10, boss.y - 20);
                    healthGradient.addColorStop(0, "#00ff00");
                    healthGradient.addColorStop(0.5, "#ffff00");
                    healthGradient.addColorStop(1, "#ff0000");
                    const healthWidth = (boss.width - 20) * (boss.health / boss.maxHealth);
                    ctx.fillStyle = healthGradient;
                    ctx.fillRect(boss.x + 10, boss.y - 20, healthWidth, 10);
                    
                    // Health bar border
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(boss.x + 10, boss.y - 20, boss.width - 20, 10);
                    ctx.restore();
                }
                
                // Draw dragon using current dragon image
                ctx.drawImage(dragonImages[currentDragon], dragon.x, dragon.y, dragon.width, dragon.height);
                
                // Flash effect when invincible
                if (powerupsActive.invincible && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(
                        dragon.x + dragon.width/2,
                        dragon.y + dragon.height/2,
                        dragon.width/2 + 5,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();
                }
                
                // Draw special power effects
                activeEffects.forEach(effect => {
                    switch(effect.type) {
                        case "powerSurge":
                            // Draw power surge effect
                            ctx.save();
                            ctx.strokeStyle = "#ff9933";
                            ctx.lineWidth = 2;
                            ctx.shadowColor = "#ff9933";
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(
                                dragon.x + dragon.width/2,
                                dragon.y + dragon.height/2,
                                dragon.width/2 + 15,
                                0,
                                Math.PI * 2
                            );
                            ctx.stroke();
                            ctx.restore();
                            break;
                            
                        case "powerSpark":
                            // Draw power sparks
                            ctx.save();
                            ctx.fillStyle = effect.color;
                            ctx.shadowColor = effect.color;
                            ctx.shadowBlur = 5;
                            ctx.beginPath();
                            ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                            break;
                            
                        case "flameShield":
                            // Draw flame shield
                            ctx.save();
                            ctx.strokeStyle = "#ff3333";
                            ctx.lineWidth = 3;
                            ctx.shadowColor = "#ff3333";
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(
                                dragon.x + dragon.width/2,
                                dragon.y + dragon.height/2,
                                dragon.width/2 + 20,
                                0,
                                Math.PI * 2
                            );
                            ctx.stroke();
                            ctx.restore();
                            break;
                            
                        case "chainLightning":
                            // Draw chain lightning
                            effect.targets.forEach(target => {
                                ctx.save();
                                ctx.strokeStyle = "#aa33ff";
                                ctx.lineWidth = 2;
                                ctx.shadowColor = "#aa33ff";
                                ctx.shadowBlur = 5;
                                ctx.beginPath();
                                ctx.moveTo(dragon.x + dragon.width/2, dragon.y + dragon.height/2);
                                ctx.lineTo(target.x + target.width/2, target.y + target.height/2);
                                ctx.stroke();
                                ctx.restore();
                            });
                            break;
                            
                        case "thunderStorm":
                            // Draw lightning bolts
                            effect.bolts.forEach(bolt => {
                                ctx.save();
                                ctx.strokeStyle = "#ffff33";
                                ctx.lineWidth = 2;
                                ctx.shadowColor = "#ffff33";
                                ctx.shadowBlur = 5;
                                ctx.beginPath();
                                ctx.moveTo(bolt.x, bolt.y);
                                ctx.lineTo(bolt.targetX, bolt.targetY);
                                ctx.stroke();
                                ctx.restore();
                            });
                            break;
                        case "iceParticle":
                            // Add ice particle effect
                            activeEffects.forEach(effect => {
                                ctx.save();
                                ctx.fillStyle = "rgba(200, 255, 255, 0.8)";
                                ctx.shadowColor = "#33ccff";
                                ctx.shadowBlur = 5;
                                ctx.beginPath();
                                ctx.arc(
                                    effect.x + Math.cos(effect.angle) * effect.speed * effect.lifetime,
                                    effect.y + Math.sin(effect.angle) * effect.speed * effect.lifetime,
                                    effect.size,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                                ctx.restore();
                            });
                            break;
                        case "iceCrystal":
                            // Add ice crystal effect
                            activeEffects.forEach(effect => {
                                ctx.save();
                                ctx.translate(effect.x, effect.y);
                                ctx.rotate(effect.rotation);
                                ctx.fillStyle = "rgba(200, 255, 255, 0.6)";
                                ctx.shadowColor = "#33ccff";
                                ctx.shadowBlur = 10;
                                
                                // Draw hexagonal ice crystal
                                ctx.beginPath();
                                for (let i = 0; i < 6; i++) {
                                    const angle = (i * Math.PI * 2) / 6;
                                    const x = Math.cos(angle) * effect.size;
                                    const y = Math.sin(angle) * effect.size;
                                    if (i === 0) ctx.moveTo(x, y);
                                    else ctx.lineTo(x, y);
                                }
                                ctx.closePath();
                                ctx.fill();
                                
                                // Add inner glow
                                ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                                ctx.beginPath();
                                for (let i = 0; i < 6; i++) {
                                    const angle = (i * Math.PI * 2) / 6;
                                    const x = Math.cos(angle) * effect.size * 0.7;
                                    const y = Math.sin(angle) * effect.size * 0.7;
                                    if (i === 0) ctx.moveTo(x, y);
                                    else ctx.lineTo(x, y);
                                }
                                ctx.closePath();
                                ctx.fill();
                                
                                ctx.restore();
                            });
                            break;
                        case "iceWave":
                            ctx.save();
                            ctx.translate(effect.x, effect.y);
                            ctx.rotate(effect.rotation);
                            
                            // Draw expanding wave
                            const waveSize = effect.size + effect.lifetime * effect.speed;
                            ctx.strokeStyle = "rgba(200, 255, 255, 0.6)";
                            ctx.lineWidth = 2;
                            ctx.shadowColor = "#33ccff";
                            ctx.shadowBlur = 10;
                            
                            ctx.beginPath();
                            ctx.arc(0, 0, waveSize, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            ctx.restore();
                            break;
                    }
                });
            }
        }

        function playSound(sound) {
            if (!muted && sound && sound.readyState >= 2) {
                sound.currentTime = 0;
                sound.play().catch(e => console.log("Error playing sound:", e));
            }
        }

        function stopAllSounds() {
            Object.values(audioElements).forEach(audio => {
                if (audio) {
                    audio.pause();
                    audio.currentTime = 0;
                }
            });
        }
    </script>
</body>
</html>